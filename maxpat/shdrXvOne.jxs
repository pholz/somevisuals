<jittershader name="shdrXvOne">
     <description>
     </description>
     <param name="pitch" type="vec2" default="0. 0." />
     <param name="pitchEffect" type="float" default="1.0"/>
     <param name="colorMode" type="int" default="0"/>
     <param name="vNoiseFactor" type="float" default="0.0"/>
     <param name="vCircleFactor" type="float" default="0.0"/>
     <param name="vCircleFactor2" type="float" default="0.0"/>
     <param name="time" type="float" default="0.0"/>
     <param name="pad1" type="float" default="0.0"/>
     <param name="timeMultiplier" type="float" default="1.0"/>
     <param name="pitchEffect" type="float" default="1.0"/>
     <param name="texmode" type="int" default="0" />
     <param name="brightness" type="float" default="1.0" />
     <param name="masterBrightness" type="float" default="1.0" />
     <param name="edgeWidth" type="float" default="1.0" />
     <param name="tex0" type="int" default="0" />
     <param name="colorMathFactor" type="float" default="0"/>
     <language name="glsl" version="1.2">

     <bind param="vCircleFactor" program="vp"/>
     <bind param="vCircleFactor2" program="vp"/>
     <bind param="vNoiseFactor" program="vp"/>
     <bind param="pitch" program="vp"/>
     <bind param="pitch" program="fp"/>
     <bind param="time" program="vp"/>
     <bind param="time" program="fp"/>
     <bind param="pad1" program="fp"/>
     <bind param="timeMultiplier" program="vp"/>
     <bind param="timeMultiplier" program="fp"/>
     <bind param="pitchEffect" program="vp"/>
     <bind param="pitchEffect" program="fp"/>
     <bind param="colorMode" program="fp"/>
     <bind param="tex0" program="fp" />
     <bind param="texmode" program="fp" />
     <bind param="brightness" program="fp" />
     <bind param="masterBrightness" program="fp" />
     <bind param="edgeWidth" program="fp" />
     <bind param="colorMathFactor" program="fp" />
     <program name="vp" type="vertex" >

<![CDATA[

#version 120

varying vec2 texcoord0;
varying vec2 texcoord1;
varying vec2 texcoord2;
varying vec2 texcoord3;
varying vec2 texcoord4;
varying vec2 texcoord5;
varying vec2 texcoord6;
varying vec2 texcoord7;

uniform float vCircleFactor;
uniform float vCircleFactor2;
uniform float vNoiseFactor;
uniform float time;
uniform float timeMultiplier;

uniform vec2 pitch;
uniform float pitchEffect;

varying vec4 worldPos;

void main()
{
    // perform standard transform on vertex

    vec4 vertpos = gl_Vertex;
    worldPos = vertpos;
    vec4 tformed = gl_ModelViewProjectionMatrix * gl_Vertex;

    float edgeX = -(gl_MultiTexCoord0.x * 2.0 - 1.0);
    float edgeY = -(gl_MultiTexCoord0.y * 2.0 - 1.0);
    vertpos.x += vCircleFactor2 * 0.5 * (1.0 - cos( (gl_MultiTexCoord0.y-0.5) * 3.14)) * edgeX;
    vertpos.x += sin(tan(time*timeMultiplier+gl_MultiTexCoord0.y*10.0)) * vNoiseFactor * edgeX * (1.0 - cos( (gl_MultiTexCoord0.y-0.5) * 3.14));

    vertpos.y += vCircleFactor2 * 0.5 * (1.0 - cos( (gl_MultiTexCoord0.x-0.5) * 3.14 * 100.0)) * edgeY;
    vertpos.y += cos(tan(time*timeMultiplier+gl_MultiTexCoord0.x*10.0)) * vNoiseFactor * edgeY * (1.0 - cos( (gl_MultiTexCoord0.x-0.5) * 3.14));

    vertpos.z += vCircleFactor * 0.5 * cos( (gl_MultiTexCoord0.y-0.5) * 3.14);
    vertpos.z += vCircleFactor * 0.5 * cos( (gl_MultiTexCoord0.x-0.5) * 3.14);

    gl_Position = gl_ModelViewProjectionMatrix * vertpos;
    gl_Position.x += pitch.x * sin(tan(vertpos.y * 100.0)) * pitchEffect * 0.02;
    gl_Position.y += pitch.x * cos(tan(vertpos.z * 100.0)) * pitchEffect * 0.02;
    gl_Position.z += pitch.x * sin(tan(vertpos.x * 100.0)) * pitchEffect * 0.02;

    // transform texcoords
    texcoord0 = vec2(gl_TextureMatrix[0] * gl_MultiTexCoord0);
    texcoord1 = vec2(gl_TextureMatrix[1] * gl_MultiTexCoord1);
    texcoord2 = vec2(gl_TextureMatrix[2] * gl_MultiTexCoord2);
    texcoord3 = vec2(gl_TextureMatrix[3] * gl_MultiTexCoord3);
    texcoord4 = vec2(gl_TextureMatrix[4] * gl_MultiTexCoord4);
    texcoord5 = vec2(gl_TextureMatrix[5] * gl_MultiTexCoord5);
    texcoord6 = vec2(gl_TextureMatrix[6] * gl_MultiTexCoord6);
    texcoord7 = vec2(gl_TextureMatrix[7] * gl_MultiTexCoord7);
}

]]>
     </program>

<program name="gp" type="geometry" vertices_out="3" input_type="triangles" output_type="triangles">

<![CDATA[

//varying vec4 bary;
#version 120
#extension GL_EXT_geometry_shader4 : enable

varying in vec2 texcoord0[3];
varying in vec2 texcoord1[3];
varying in vec4 worldPos[3];

varying out vec2 texcoord0f;
varying out vec2 texcoord1f;
varying out vec4 worldPosf;
varying out vec3 bary;

void main()
{
    gl_Position = gl_PositionIn[0];
    texcoord0f = texcoord0[0];
    texcoord1f = texcoord1[0];
    worldPosf = worldPos[0];
    bary = vec3(1.0f, 0.0f, 0.0f);
    EmitVertex();

    gl_Position = gl_PositionIn[1];
    texcoord0f = texcoord0[1];
    texcoord1f = texcoord1[1];
    worldPosf = worldPos[1];
    bary = vec3(0.0f, 1.0f, 0.0f);
    EmitVertex();

    gl_Position = gl_PositionIn[2];
    texcoord0f = texcoord0[2];
    texcoord1f = texcoord1[2];
    worldPosf = worldPos[2];
    bary = vec3(0.0f, 0.0f, 1.0f);
    EmitVertex();

    EndPrimitive();
}

]]>

</program>

     <program name="fp" type="fragment">

<![CDATA[
#version 120
varying vec2 texcoord0f;
varying vec2 texcoord1f;

uniform vec2 pitch;
uniform float pitchEffect;
uniform sampler2D tex0;
uniform int texmode;
uniform float brightness;
uniform float masterBrightness;
uniform int colorMode;
uniform float time;
uniform float timeMultiplier;
uniform float pad1;
uniform float edgeWidth;
uniform float colorMathFactor;

const float PI = 3.1415927;

varying vec4 worldPosf;
varying vec3 bary;

#extension GL_OES_standard_derivatives : enable
float edgeFactor(){
    vec3 d = fwidth(bary);
    vec3 a3 = smoothstep(vec3(0.0), d*edgeWidth, bary);
    return min(min(a3.x > 0.5 ? 1.0 : 0.0, a3.y > 0.5 ? 1.0 : 0.0), a3.z > 0.5 ? 1.0 : 0.0);
}

// entry point
void main()
{
        float r, theta, x, y;
        vec2 xynorm;

        vec4 finalColor = vec4(1.0, 1.0, 1.0, 1.0);



        if (texmode > 0)
        {
                if (texmode == 1) // linear
                {
                    finalColor = texture2D(tex0, /*texcoord0f.xy*/ vec2(0.0,0.0) * vec2(0.16, 1.0));// * pitch.x;// + vec4(0.0, 0.5, 0.0, 1.0);
                        finalColor = min(finalColor, vec4(1.0, 1.0, 1.0, 1.0));
                        //  finalColor = finalColor * pow( 2.0*(0.9 - abs(texcoord0.y - 0.5)), 3.0);
                }
                else if (texmode == 2) // radial
                {
                        r = distance(texcoord0f, vec2(0.5, 0.5));
                        xynorm = texcoord0f - vec2(0.5, 0.5);
                        theta = atan(xynorm.y, xynorm.x);
                        x = r * cos(theta);
                        y = r * sin(theta);
                        finalColor = texture2D(tex0, vec2(r * 2.0, theta));
                        if (r > .4)
                                finalColor = vec4(0.0);
                }
                else
                {
                    finalColor = texture2D(tex0, texcoord0f * 0.95);
                    finalColor = min(finalColor, vec4(1.0, 1.0, 1.0, 1.0));
                    if (sqrt(finalColor.r)/2.0 < distance(texcoord0f.y, 0.5))
                        finalColor *= 0.0;

                }
        }

        if (colorMode == 0)
            finalColor.rg *= mix(1.0, pitch.x, pitchEffect * 0.6);
        else
            finalColor.bg *= mix(1.0, pitch.x, pitchEffect * 0.6);

        float rgbsum = finalColor.r * 0.33 + finalColor.g * 0.33 + finalColor.b * 0.33;
        if (rgbsum < 0.05)
                finalColor *= 0.0;

        finalColor.x += pad1;

        gl_FragColor = finalColor + colorMathFactor * vec4(sin(tan((worldPosf.z)*10.0 * worldPosf.x*3.0 + worldPosf.y*5.0 + (time*timeMultiplier)) * 0.06), 0.0, 0.0,1.0);// * sin(worldPos.y * 30.0 + time * timeMultiplier);
        gl_FragColor.a *= 0.7;
        float blend = edgeFactor();

        gl_FragColor.rgb *= mix(vec3(1.0), vec3(0.0), blend);
        gl_FragColor.rgb *= brightness * masterBrightness;
        gl_FragColor.a = finalColor.r * 0.33 + finalColor.g * 0.33 + finalColor.b * 0.33;

}

]]>
		</program>
	</language>
</jittershader>
